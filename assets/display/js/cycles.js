'use strict';

/**
 * Major and Annual Cycles Display Module
 * 
 * Corresponding CSS: assets/display/css/cycles.css
 */

(function() {
    function getAdapterModule(name) {
        const adapter = window.ziweiAdapter;
        if (!adapter) {
            return null;
        }
        if (typeof adapter.getModule === 'function') {
            return adapter.getModule(name);
        }
        const modules = adapter.modules || {};
        return modules[name] || null;
    }

    function getAdapterStorageValue(key) {
        const adapter = window.ziweiAdapter;
        if (!adapter || !adapter.storage || typeof adapter.storage.get !== 'function') {
            return null;
        }
        try {
            return adapter.storage.get(key);
        } catch (e) {
            return null;
        }
    }

    /**
     * Initialize the major/annual cycle panel displayed under the chart.
     * @param {Object} lifeCycleData Life cycle payload generated by chart.js draw()
     * @param {HTMLElement} grid The 4x4 grid element for palace highlighting
     * @param {Object} [palaceInteraction=null] API returned by initializePalaceInteraction
     * @returns {HTMLElement|null} Rendered panel element or null if data missing
     */
    function initializeCyclePanel(lifeCycleData = {}, grid, palaceInteraction = null) {
        const majorCycles = Array.isArray(lifeCycleData?.majorCycles) ? lifeCycleData.majorCycles : [];
        const palaceData = lifeCycleData?.palaceData || {};
        const timeIndex = lifeCycleData?.timeIndex;

    // cycles initialized

        if (!grid || majorCycles.length === 0) {
            return null;
        }

        const panel = document.createElement('div');
        panel.className = 'ziwei-cycle-panel';

        // Major cycle section
        const majorSection = document.createElement('div');
        majorSection.className = 'ziwei-cycle-section';
        panel.appendChild(majorSection);

        const majorLabel = document.createElement('div');
        majorLabel.className = 'ziwei-cycle-label';
        majorLabel.textContent = '大限';
        majorSection.appendChild(majorLabel);

        const majorRow = document.createElement('div');
        majorRow.className = 'ziwei-cycle-row ziwei-major-cycle-row';
        majorSection.appendChild(majorRow);

        // Annual cycle section
        const annualSection = document.createElement('div');
        annualSection.className = 'ziwei-cycle-section';
        panel.appendChild(annualSection);

        const annualLabel = document.createElement('div');
        annualLabel.className = 'ziwei-cycle-label';
        annualLabel.textContent = '流年';
        annualLabel.style.display = 'none';
        annualSection.appendChild(annualLabel);

        const annualRow = document.createElement('div');
        annualRow.className = 'ziwei-cycle-row ziwei-annual-cycle-row';
        annualRow.style.display = 'none';
        annualSection.appendChild(annualRow);

    let activeMajorButton = null;
        let isProcessingCycleClick = false;

        /**
         * Generate major cycle labels (大限 clockwise sequence)
         * Dynamically applies user's palace name preferences:
         * - Position 4: 大事 (default) or 大官 (if user selected 官祿)
         * - Position 5: 大友 (default) or 大僕/大僕 (if user selected 奴僕/僕役)
         * @returns {Array<string>} Array of 12 labels for 大限
         */
        const generateMajorLabels = () => {
            const adapter = window.ziweiAdapter;
            const baseLabels = ['大命','大父','大福','大田','大事','大友','大遷','大疾','大財','大子','大夫','大兄'];
            
            // Read user's palace name settings from adapter
            if (!adapter || !adapter.settings || typeof adapter.settings.get !== 'function') {
                return baseLabels;
            }
            
            const careerSetting = adapter.settings.get('palaceNameCareer') || 'career';
            const friendsSetting = adapter.settings.get('palaceNameFriends') || 'friends';
            
            // Apply career palace setting (position 4)
            if (careerSetting === 'official') {
                baseLabels[4] = '大官';
            }
            
            // Apply friends palace setting (position 5)
            if (friendsSetting === 'servants') {
                baseLabels[5] = '大僕';
            } else if (friendsSetting === 'servants_alt') {
                baseLabels[5] = '大僕';
            }
            
            return baseLabels;
        };

        /**
         * Generate annual cycle labels (流年 clockwise sequence, excluding main palace)
         * Dynamically applies user's palace name preferences:
         * - Position 4: 流事 (default) or 流官 (if user selected 官祿)
         * - Position 5: 流友 (default) or 流僕 (if user selected 奴僕/僕役)
         * @returns {Array<string>} Array of 11 labels for 流年 (skip main palace)
         */
        const generateAnnualLabels = () => {
            const adapter = window.ziweiAdapter;
            const baseLabels = ['流父','流福','流田','流事','流友','流遷','流疾','流財','流子','流夫','流兄'];
            
            // Read user's palace name settings from adapter
            if (!adapter || !adapter.settings || typeof adapter.settings.get !== 'function') {
                return baseLabels;
            }
            
            const careerSetting = adapter.settings.get('palaceNameCareer') || 'career';
            const friendsSetting = adapter.settings.get('palaceNameFriends') || 'friends';
            
            // Apply career palace setting (position 3 in ANNUAL_LABELS array = position 4 relative to Ming)
            if (careerSetting === 'official') {
                baseLabels[3] = '流官';
            }
            
            // Apply friends palace setting (position 4 in ANNUAL_LABELS array = position 5 relative to Ming)
            if (friendsSetting === 'servants') {
                baseLabels[4] = '流僕';
            } else if (friendsSetting === 'servants_alt') {
                baseLabels[4] = '流僕';
            }
            
            return baseLabels;
        };

        const clearCycleState = () => {
            // Don't clear if we're in the middle of processing a cycle button click
            if (isProcessingCycleClick) return;
            if (activeMajorButton) {
                activeMajorButton.classList.remove('ziwei-cycle-button-active');
            }
            activeMajorButton = null;
            annualRow.innerHTML = '';
            annualRow.style.display = 'none';
            annualLabel.style.display = 'none';
            window.ziweiChartHelpers?.clearMajorCycleStars?.();
            window.ziweiChartHelpers?.clearMajorCycleMutations?.();
            window.ziweiChartHelpers?.clearMajorMingLabel?.();
            // Also clear any multi-palace major-cycle labels
            window.ziweiChartHelpers?.clearMajorCycleLabels?.();
            // Clear any multi-palace annual-cycle labels
            window.ziweiChartHelpers?.clearAnnualCycleLabels?.();
            window.ziweiChartHelpers?.clearAnnualCycleMutations?.();
            window.ziweiChartHelpers?.clearAnnualMingLabel?.();
        };

        const highlightPalace = (palaceIndex) => {
            if (palaceInteraction && typeof palaceInteraction.highlight === 'function') {
                palaceInteraction.highlight(palaceIndex);
                return;
            }

            // Fallback: find cell and click it
            const fallbackCell = grid.querySelector(`.ziwei-cell[data-branch-index="${palaceIndex}"]`);
            if (fallbackCell) {
                fallbackCell.click();
            }
        };

        /**
         * Get earthly branch (地支) character for a given year
         * Uses window.ziweiConstants.BRANCH_NAMES for consistent naming
         * @param {number} year The year
         * @returns {string} Branch character (子-亥)
         */
        const getEarthlyBranchChar = (year) => {
            const branchNames = window?.ziweiConstants?.BRANCH_NAMES;
            if (!Array.isArray(branchNames) || branchNames.length !== 12) {
                throw new Error('[cycles.js] BRANCH_NAMES not available from constants');
            }
            const basicModule = getAdapterModule('basic');
            if (basicModule && typeof basicModule.getEarthlyBranchIndex === 'function') {
                const branchIndex = basicModule.getEarthlyBranchIndex(year);
                return branchNames[branchIndex] || '';
            }
            return '';
        };
        /**
         * Convert branch character to branch index (0-11)
         * Uses window.ziweiConstants.BRANCH_NAMES for consistent lookup
         * @param {string} branchChar Branch character (子-亥)
         * @returns {number} Branch index (0-11), or -1 if not found
         */
        const branchCharToIndex = (branchChar) => {
            const branchNames = window?.ziweiConstants?.BRANCH_NAMES;
            if (!Array.isArray(branchNames) || branchNames.length !== 12) {
                throw new Error('[cycles.js] BRANCH_NAMES not available from constants');
            }
            return branchNames.indexOf(branchChar);
        };
        const getPalaceStemBranch = (palaceIndex) => {
            if (palaceData && palaceData[palaceIndex]) {
                const palace = palaceData[palaceIndex];
                return (palace.stem || '') + (palace.branchZhi || '');
            }
            return '';
        };

        const lunarYear = (function() {
            const adapterOutput = getAdapterStorageValue('adapterOutput');
            // Prefer the adapter's canonical lunar numeric fields. The adapter
            // exposes lunar.lunarYear and may also provide a numeric snapshot
            // under meta.birthdateLunarNumeric.lunarYear.
            if (Number.isInteger(adapterOutput?.lunar?.lunarYear)) {
                return adapterOutput.lunar.lunarYear;
            }
            if (Number.isInteger(adapterOutput?.lunar?.year)) {
                // some older adapter shapes might use `year`
                return adapterOutput.lunar.year;
            }
            if (Number.isInteger(adapterOutput?.meta?.birthdateLunarNumeric?.lunarYear)) {
                return adapterOutput.meta.birthdateLunarNumeric.lunarYear;
            }
            if (Number.isInteger(adapterOutput?.meta?.lunarYear)) {
                return adapterOutput.meta.lunarYear;
            }
            console.error('[ziweiCycles] Missing lunar year in adapterOutput snapshot', adapterOutput, getAdapterStorageValue('meta'));
            return null;
        })();

    // year extraction result available

        /**
         * Get heavenly stem (天干) character for a given year
         * Uses window.ziweiConstants.STEM_NAMES for consistent naming
         * @param {number} year The year
         * @returns {string} Stem character (甲-癸)
         */
        const getHeavenlyStemChar = (year) => {
            const stemNames = window?.ziweiConstants?.STEM_NAMES;
            if (!Array.isArray(stemNames) || stemNames.length !== 10) {
                throw new Error('[cycles.js] STEM_NAMES not available from constants');
            }
            const basicModule = getAdapterModule('basic');
            if (basicModule && typeof basicModule.getHeavenlyStemIndex === 'function') {
                const stemIndex = basicModule.getHeavenlyStemIndex(year);
                return stemNames[stemIndex] || '';
            }
            return '';
        };

        /**
         * Get the stem-branch (天干地支) characters for a given year
         * @param {number} year The year
         * @returns {string} Stem-branch combination (e.g., "甲子")
         */
        const getStemBranchForYear = (year) => {
            return getHeavenlyStemChar(year) + getEarthlyBranchChar(year);
        };

        const renderAnnualRow = (cycle) => {
            annualRow.innerHTML = '';
            window.ziweiChartHelpers?.clearAnnualMingLabel?.();
            window.ziweiChartHelpers?.clearAnnualCycleLabels?.();
            window.ziweiChartHelpers?.clearAnnualCycleMutations?.();

            // Strict requirement: must have lunarYear to compute actual years.
            if (!Number.isInteger(lunarYear)) {
                console.error('ziweiCycles: unable to render annual years — missing lunarYear', {
                    lunarYear,
                    adapterMeta: getAdapterStorageValue('meta'),
                    gridDataset: grid?.dataset
                });
                // Do not show the annual row when data insufficient (no fallback assumptions).
                annualRow.style.display = 'none';
                annualLabel.style.display = 'none';
                return;
            }

            for (let offset = 0; offset < 10; offset++) {
                const age = cycle.startAge + offset;
                const annualBtn = document.createElement('button');
                annualBtn.type = 'button';
                annualBtn.className = 'ziwei-cycle-button ziwei-annual-cycle-button';
                annualBtn.dataset.age = String(age);
                annualBtn.dataset.cycleIndex = String(cycle.cycleIndex);

                // Compute displayed year: lunarYear + startAge + offset - 1
                // Example: lunarYear=1989, cycle 12-21, offset=0 => 1989+12-1=2000
                const displayYear = lunarYear + cycle.startAge + offset - 1;
                const stemBranch = getStemBranchForYear(displayYear);
                
                // Create button content: year on top, stem-branch + age on bottom
                const yearSpan = document.createElement('div');
                yearSpan.className = 'ziwei-annual-year';
                yearSpan.textContent = `${displayYear}年`;
                
                const stemBranchSpan = document.createElement('div');
                stemBranchSpan.className = 'ziwei-annual-stem-branch';
                stemBranchSpan.textContent = `${stemBranch}${age}歲`;
                
                annualBtn.appendChild(yearSpan);
                annualBtn.appendChild(stemBranchSpan);
                annualBtn.dataset.year = String(displayYear);

                // Add click event to annual button for highlighting palace and showing annual stars
                    annualBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        // Extract branch character from stem-branch (last character is branch)
                        const stemChar = stemBranch.charAt(0);
                        const branchChar = stemBranch.charAt(1);
                        const branchIndex = branchCharToIndex(branchChar);
                        if (branchIndex >= 0 && branchIndex < 12) {
                        // Prevent clear callbacks from wiping state while we update the view
                        isProcessingCycleClick = true;

                        // Highlight this annual button (add active class)
                        const allAnnualButtons = annualRow.querySelectorAll('.ziwei-annual-cycle-button');
                        allAnnualButtons.forEach(btn => {
                            btn.classList.remove('ziwei-cycle-button-active');
                        });
                        annualBtn.classList.add('ziwei-cycle-button-active');

                        // Highlight the palace based on branch index
                        highlightPalace(branchIndex);

                        // Show annual stars - ADD to existing major cycle stars, don't replace them
                        window.ziweiChartHelpers?.showAnnualCycleStars?.({
                            age: age,
                            year: displayYear,
                            branchIndex: branchIndex,
                            stemChar: stemChar,
                            timeIndex: timeIndex
                        });

                        // Also render the clockwise sequence of annual labels (skip the main 年命 palace)
                        // Apply user's palace name preferences dynamically
                        const ANNUAL_LABELS = generateAnnualLabels();
                        window.ziweiChartHelpers?.setAnnualCycleLabels?.(branchIndex, ANNUAL_LABELS);

                        // Apply annual cycle mutations (流年四化)
                        if (stemChar) {
                            window.ziweiChartHelpers?.applyAnnualCycleMutations?.(stemChar);
                        }

                        // Allow deferred clear callbacks to run after highlight completes
                        setTimeout(() => {
                            isProcessingCycleClick = false;
                        }, 100);
                    }
                });

                annualRow.appendChild(annualBtn);
            }
            annualRow.style.display = 'grid';
            annualLabel.style.display = 'block';
        };

        const handleMajorCycleSelection = (cycle, stemBranch) => {
            if (!cycle) return;

            const palace = palaceData?.[cycle.palaceIndex] || null;
            const cycleStem = palace?.stem || (stemBranch ? stemBranch.charAt(0) : '');
            const cycleBranchIndex = palace?.index;

            window.ziweiChartHelpers?.showMajorCycleStars?.({ 
                cycle, 
                stem: cycleStem,
                branchIndex: cycleBranchIndex,
                timeIndex: timeIndex,
                palaceData: palaceData
            });
            // Apply major cycle mutations (大限四化)
            if (cycleStem) {
                window.ziweiChartHelpers?.applyMajorCycleMutations?.(cycleStem);
            }
            // Render the full clockwise sequence of 大限 labels around 命宮
            // Apply user's palace name preferences dynamically
            if (Number.isInteger(cycleBranchIndex)) {
                const MAJOR_LABELS = generateMajorLabels();
                window.ziweiChartHelpers?.setMajorCycleLabels?.(cycleBranchIndex, MAJOR_LABELS);
            }
        };

        majorCycles.forEach((cycle) => {
            const stemBranch = getPalaceStemBranch(cycle.palaceIndex);
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'ziwei-cycle-button ziwei-major-cycle-button';
            const labelText = stemBranch ? `${stemBranch}限` : '大限';
            btn.dataset.cycleIndex = String(cycle.cycleIndex);
            btn.dataset.palaceIndex = String(cycle.palaceIndex);
            btn.dataset.ageRange = cycle.ageRange;

            const labelSpan = document.createElement('span');
            labelSpan.className = 'ziwei-cycle-button-label';
            labelSpan.textContent = labelText;
            btn.appendChild(labelSpan);

            const ageSpan = document.createElement('span');
            ageSpan.className = 'ziwei-cycle-button-age';
            ageSpan.textContent = cycle.ageRange;
            btn.appendChild(ageSpan);

                btn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();

                // Set flag to prevent clearCycleState from running during our click handling
                isProcessingCycleClick = true;

                // Remove active class from all buttons first
                const allButtons = majorRow.querySelectorAll('.ziwei-cycle-button');
                allButtons.forEach(b => {
                    b.classList.remove('ziwei-cycle-button-active');
                });

                // Add active class to clicked button
                btn.classList.add('ziwei-cycle-button-active');
                activeMajorButton = btn;
                
                // Verify class was added
                // Verify class was added (no debug log)

                highlightPalace(cycle.palaceIndex);
                renderAnnualRow(cycle);
                handleMajorCycleSelection(cycle, stemBranch);

                // Reset flag after a short delay to allow palace highlight to complete
                setTimeout(() => {
                    isProcessingCycleClick = false;
                }, 100);
            });

            majorRow.appendChild(btn);
        });

        // Hook into palace interaction to clear cycle state when clicking center
            if (grid && palaceInteraction && typeof palaceInteraction.onClear === 'function') {
                palaceInteraction.onClear(() => {
                    clearCycleState();
                });
            } else if (grid) {
                // Fallback: listen for center cell clicks
                grid.addEventListener('click', (e) => {
                    const cellElement = e.target.closest('.ziwei-cell');
                    if (!cellElement || cellElement.classList.contains('ziwei-center-big')) {
                        clearCycleState();
                    }
                });
            }

        // Listen for palace name setting changes and update cycle labels in real-time
        document.addEventListener('ziwei-palace-name-changed', function handleCyclePalaceNameChange(e) {
            const detail = e && e.detail ? e.detail : {};
            const settingName = detail.settingName || '';
            
            // Only update if the affected setting is career or friends palace name
            if (settingName !== 'palaceNameCareer' && settingName !== 'palaceNameFriends') {
                return;
            }
            
            // Always clear existing cycle labels first (defensive, prevents lingering labels)
            if (typeof window.ziweiChartHelpers?.clearMajorCycleLabels === 'function') {
                window.ziweiChartHelpers.clearMajorCycleLabels();
            }
            if (typeof window.ziweiChartHelpers?.clearAnnualCycleLabels === 'function') {
                window.ziweiChartHelpers.clearAnnualCycleLabels();
            }
            
            // If there's an active major cycle button, regenerate and apply major labels
            if (activeMajorButton && typeof window.ziweiChartHelpers?.setMajorCycleLabels === 'function') {
                const cycleIndex = parseInt(activeMajorButton.dataset.cycleIndex, 10);
                const palaceIndex = parseInt(activeMajorButton.dataset.palaceIndex, 10);
                
                // Reconstruct cycle object for label generation
                if (Number.isInteger(palaceIndex)) {
                    const palace = palaceData?.[palaceIndex] || null;
                    if (palace && Number.isInteger(palace.index)) {
                        const MAJOR_LABELS = generateMajorLabels();
                        window.ziweiChartHelpers.setMajorCycleLabels(palace.index, MAJOR_LABELS);
                    }
                }
            }
            
            // If annual row is visible, regenerate and apply annual labels
            if (annualRow && annualRow.style.display !== 'none' && typeof window.ziweiChartHelpers?.setAnnualCycleLabels === 'function') {
                const annualBtnActive = annualRow.querySelector('.ziwei-cycle-button-active');
                if (annualBtnActive) {
                    const annualAge = parseInt(annualBtnActive.dataset.age, 10);
                    const cycleIndex = parseInt(annualBtnActive.dataset.cycleIndex, 10);
                    
                    if (Number.isInteger(cycleIndex)) {
                        // Find the cycle object to get branchIndex
                        const cycleLookup = majorCycles.find(c => c.cycleIndex === cycleIndex);
                        if (cycleLookup && palaceData) {
                            const stemBranch = getPalaceStemBranch(cycleLookup.palaceIndex);
                            if (stemBranch && stemBranch.length >= 2) {
                                const branchChar = stemBranch.charAt(1);
                                const branchIndex = branchCharToIndex(branchChar);
                                if (Number.isInteger(branchIndex) && branchIndex >= 0) {
                                    const ANNUAL_LABELS = generateAnnualLabels();
                                    window.ziweiChartHelpers.setAnnualCycleLabels(branchIndex, ANNUAL_LABELS);
                                }
                            }
                        }
                    }
                }
            }
        });

        return panel;
    }

    window.ziweiCycles = {
        initializeCyclePanel
    };
})();
